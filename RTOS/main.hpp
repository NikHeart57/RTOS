/**
 *
 * Сначала теория ООП потому что у меня склероз и лень, отчего я не могу уже 2 года это выучить :(
 *
 * Основные принципы объектно-ориентированного программирования (ООП) — это 
 *	Абстракция
 *	Инкапсуляция 
 *	Наследование
 *	Полиморфизм
 *
 * Эти принципы помогают разработчикам создавать модульные, повторно используемые и легко поддерживаемые компоненты ПО, 
 * скрывая ненужные детали, объединяя данные с методами, позволяя создавать новые классы на основе существующих и обрабатывать объекты по-разному.
 *
 *	Абстракция
 *		Суть:		Выделение основных, важных для задачи характеристик объекта и сокрытие второстепенных деталей.
 *		Пример:		При использовании лампочки мы не знаем её внутреннее устройство, а только знаем, что её можно включить или выключить.
 *
 *	Инкапсуляция
 *		Суть:		Объединение данных (атрибутов) и методов (функций) объекта в единое целое, а также сокрытие внутренней реализации объекта от внешнего мира.
 *		Пример:		У объекта "Машина" есть свойства (скорость, цвет) и методы (поехать). Внешний мир видит, как машина едет, но не видит сложную механику.
 *
 *	Наследование
 *		Суть:		Создание новых классов (объектов-потомков) на основе существующих (объектов-родителей), перенимая их свойства и методы.
 *		Пример:		От класса "Животное" можно создать класс "Собака", добавив новый метод "лаять".
 *
 * Полиморфизм
 *		Суть:		Способность объектов разных классов выполнять один и тот же метод по-разному.
 *		Пример:		Команда "прыгать" будет реализована по-разному для объектов "Кошка" и "Лягушка".
 *
 *
 *
 *
 *
 * Теперь по проекту:
 * Эволюция архитектуры: от "Владелец-Ресурс" к "Микроядру RTOS".
 *
 * Изначальный паттерн "Владелец-Ресурс" (Owner-Resource Pattern) был хорошим началом.
 * С добавлением планировщика задач система эволюционировала в нечто большее — простую, но полноценную RTOS (Real-Time Operating System).
 * Ядро (SystemKernel) теперь является не просто менеджером, а **микроядром**.
 *
 * 1. Драйвер (Driver) — КАК сделать? (Слой реализации)
 *	Назначение: 
 *		Низкоуровневая работа непосредственно с железом микроконтроллера. Переводящая язык регистров на язык функций.
 *	Уровень: 
 *		Аппаратный (Hardware), максимально близко к "металлу".
 *  Знает:
 *		Адреса регистров (SFR), битовые маски.
 *		Процедуры инициализации, тайминги.
 *		Обработчики прерываний (ISR).
 *  Не знает:
 *		Бизнес-логику приложения.
 *		Существование других драйверов или ресурсов.
 *		Состояние системы.
 *  Ответственность:
 *		Прямое управление периферией через запись/чтение регистров.
 *		Предоставление чистого, минималистичного API для управления конкретным блоком (например, UART_SendByte(), GPIO_SetPin()).
 *  Аналог: Водитель такси, который идеально знает устройство своей машины и как ей управлять, но не знает, куда и зачем едет пассажир.
 * 
 *
 * 2. Ресурс (Resource) — ЧЕМ сделать? (Слой абстракции)
 *	Назначение: 
 *		Высокоуровневая абстракция аппаратного или логического компонента системы. Инкапсуляция драйвера и предоставление удобного, 
 *		безопасного API в соответствии с принципами ООП.
 *	Уровень: 
 * 		Абстракционный (Middleware).
 *	Знает:
 *		Интерфейс своего драйвера (использует его, но не знает его реализации).
 *		Свое внутреннее состояние (включен/выключен, настроен, данные в буфере).
 *		Свой жизненный цикл (RAII: конструктор/деструктор).
 *	Не знает:
 *		Как именно работает железо "под капотом" (это знает драйвер).
 *		Кто и как его использует (это знает ядро).
 *	Ответственность:
 *		Управление жизненным циклом компонента: инициализация, конфигурация, безопасное выключение.
 *		Предоставление идиоматичного C++ интерфейса (напр., uart.write("Hello"), timer.start()).
 *		Обработка ошибки и управление состоянием на своем уровне.
 * Аналог: 
 *		Такси-сервис (например, Uber). У него есть водители (драйверы) и машины (железо). 
 *		Он предоставляет вам простой интерфейс (приложение) для вызова машины, скрывая от вас все детали: 
 *		какого конкретно водителя он найдет, на какой именно машине он приедет.
 * 
 *
 * 3. Ядро ОС (OS Kernel) / Владелец (Owner) — КТО, КОГДА и В КАКОЙ ПОСЛЕДОВАТЕЛЬНОСТИ использует? (Слой координации + Управление выполнением)
 *  Назначение:
 *       Высший орган управления, который не только владеет всеми ресурсами, но и управляет временем выполнения задач.
 *       Это "мозг" и "сердце" системы, дирижер оркестра.
 *  Уровень:
 *       Системный (System), уровень операционной системы.
 *  НОВЫЕ ОБЯЗАННОСТИ (помимо старых):
 *       Владение задачами (Task Ownership): Создание, управление жизненным циклом и уничтожение задач.
 *       Планирование (Scheduling): Решение, КАКАЯ задача должна выполняться в данный момент времени, на основе приоритетов и состояний (READY, SLEEPING, SUSPENDED).
 *       Синхронизация (Synchronization): Предоставление механизмов для координации взаимодействия задач (например, сон на определенное время `sleep()`).
 *       Управление временем (Time Management): Подсчет системных тиков, которые являются "пульсом" всей ОС.
 *  Знает:
 *       ВСЕ ресурсы и ВСЕ задачи в системе.
 *       Состояние всей системы и расписание выполнения.
 *	Не знает:
 *		Как работают драйверы (он работает только с интерфейсами ресурсов).
 *		Детали реализации железа.
 *	Ответственность:
 *		Владение (Ownership): Создание и время жизни всех ключевых ресурсов.
 *		Координация: Связывание ресурсов между собой. Например, "по получению данных по UART (UART_Resource), записать их в файл на SD-карту (SD_Resource)".
 *		Предоставление доступа: Разрешение другим, менее значимым модулям, заимствовать ресурсы (через методы типа getUART()) для выполнения конкретных задач.
 *		Обеспечение целостности системы: Контроль за тем, чтобы конфликтующие ресурсы не использовались одновременно.
 *       + Диспетчеризация задач (вызов функции `dispatch()` в бесконечном цикле).
 *       + Обработка прерывания системного таймера и обновление состояний задач (`tick()`).
 *   Аналог:
 *       Диспетчерская служба такси + аэропорт с диспетчерской вышкой.
 *       Вы не только раздаете машины (ресурсы), но и принимаете заказы (задачи) от клиентов,
 *       составляете оптимальный график движения всех машин, следите за их местоположением и состоянием (свободна/занята/на заправке),
 *       и даете команды, кому куда ехать следующему.
 *
 * 4. Приложение (Application) — ЗАЧЕМ? (Слой бизнес-логики, разбитый на задачи)
 *   Назначение:
 *       Реализация конечной цели устройства, представленная в виде набора независимых или слабосвязанных задач (функций).
 *       Каждая задача инкапсулирует свой собственный, часто бесконечный, алгоритм.
 *   Уровень:
 *       Прикладной (Application), но теперь структурированный.
 *   НОВАЯ СТРУКТУРА:
 *       Приложение больше не является монолитом с одним методом `run()`.
 *       Оно регистрирует в ядре одну или несколько функций-задач с указанием их приоритета.
 *       Логика приложения распределена между этими задачаи.
 *	Знает:
 *		Зачем нужны ресурсы. Понимает сценарии использования: "если получена команда 'включи' по UART, то установить вывод GPIO в HIGH".
 *		Конечные автоматы (state machines) поведения устройства.
 *		Протоколы прикладного уровня, алгоритмы обработки данных.
 *		Состояние выполняемой задачи (например, прогресс передачи файла).
 *		+ Как разбить глобальную бизнес-логику на отдельные потоки выполнения (задачи).
 *	Не знает:
 *		Как реализованы ресурсы и драйверы. Для него UART — это просто объект с методом println(), а не набор регистров USART.
 *		Как ядро управляет доступом к ресурсам. Оно просто запрашивает их и использует.
 *       + Когда и как часто она будет выполняться. Это решает ядро-планировщик.
 *       + Каждая задача должна быть написана так, чтобы не блокировать надолго выполнение (быть "дружелюбной" к кооперативному планировщику).
 *       + Задача должна либо завершаться за разумное время, либо явно возвращать управление ядру (через `sleep()` или другие будущие механизмы).
 *   Аналог:
 *       Теперь это не просто "Служба доставки пиццы", а "Центр управления полетами".
 *       Одна задача (диспетчер) следит за поступлением новых заказов (UART).
 *       Вторая задача (логист) планирует маршруты для курьеров.
 *       Третья задача (отчетность) раз в час отправляет статистику на сервер.
 *       Все они работают параллельно (квази-параллельно), независимо друг от друга, под управлением ядра-диспетчера.
 *
 *
 *   Драйверы (GPIO, UART): Чистый, низкоуровневый, процедурный C-код. Знает ТОЛЬКО о регистрах микроконтроллера.
 *       Это слой "КАК?".
 *   Ресурсы (UART_Resource): Классы C++, которые инкапсулируют драйверы. Предоставляют удобный, безопасный и объектно-ориентированный API.
 *       Это слой "ЧЕМ?".
 *   Ядро ОС (SystemKernel): Выступает в роли "Микроядра". Оно владеет всеми ресурсами и всеми задачами. Управляет доступом к ресурсам и планирует выполнение задач.
 *       Это слой "КТО? КОГДА? И В КАКОМ ПОРЯДКЕ?".
 *   Приложение (Application): Набор задач, реализующих бизнес-логику. Использует ресурсы, предоставленные ядром, для выполнения полезной работы.
 *       Это слой "ЗАЧЕМ?", разбитый на модули ("зачем-1", "зачем-2", ...).
 *
 *
 *   Схема архитектуры:
 *
 *       [ main.cpp ] (Точка входа)
 *             |
 *             | Создает и настраивает
 *             V
 *       [ System Kernel ] (Микроядро)  <---- (Владеет и управляет) ---- [ Task 1 ] (ЗАЧЕМ-1?)
 *           |            |                                              [ Task 2 ] (ЗАЧЕМ-2?)
 *           |            | Планирует, диспетчеризирует (КТО? КОГДА?)    [ Task 3 ] (ЗАЧЕМ-3?)
 *           |            |                                               [ ... ]
 *           |            |                                                  ^
 *           |            | Управляет временем (tick!)                       |
 *           |            V                                                  |
 *           |    [ TaskManager ] (Компонент ядра) --------------------------|
 *           |            | ^
 *           |            | | (Вызов из прерывания)
 *           |            V |
 *           |    [ System Timer ] (Аппаратное прерывание)
 *           |
 *           | Владеет, предоставляет доступ
 *           V
 *       [ ResourceManager ]   [ Другие менеджеры ]  (ЧЕМ? Абстракция)
 *               |                   |
 *               | Использует        | Использует
 *               V                   V
 *       [ UART_Resource ]     [ Другие ресурсы ]    
 *               |                   |
 *               | Использует        | Использует
 *               V                   V
 *       [ UART Driver ]     [ Другие драйверы ]    (КАК? Реализация)
 *               |                   |
 *               | Дергает           | Дергает
 *               V                   V
 *       [ UART Hardware ]   [ Другое железо ]  (Железо)
 *
 *
 * Краткое резюме по схеме:
 *
 *  Application (Приложение)
 *       Говорит ядру: "Вот тебе три задачи, которые нужно выполнять: heartbeat, чтение датчика, опрос кнопки. Вот их приоритеты."
 *  System Kernel (Ядро ОС)
 *       Знает: У него есть задачи T1, T2, T3 и ресурсы UART, SPI.
 *       Делает: "Так, задача чтения датчика (T2) с высоким приоритетом проснулась -> выполняю её. Она запросила UART -> даю ей ресурс."
 *       Делает: "T2 завершила работу с UART и уснула на 500 мс -> возвращаю ресурс UART. Теперь самая старшая готовая задача - T1 -> выполняю её."
 *  TaskManager (Планировщик)
 *       Вызывается из бесконечного цикла ядра `dispatch()`. Постоянно сканирует список задач, выбирает лучшую кандидатуру на выполнение.
 *       Вызывается из прерывания таймера `tick()`. Уменьшает счетчики сна для всех спящих задач.
 *	UART_Resource (Ресурс)
 *		Знает: У него есть драйвер UART_SendByte().
 *		Сделает: "Драйвер, отправь эти символы!" -> UART_SendBuffer(data, length);
 *  UART Driver (Драйвер)
 *		Знает: Адрес регистра UDR и бит UDRE.
 *		Сделает: while(!(UCSRA & (1<<UDRE))); UDR = data;
 *  UART Hardware (Железо)
 *		Сделает: "О, в моём регистре UDR данные! Надо отправить их по проводу."
 *
 *
 *
 *
 *
 *
 * Про ядро и про приложение
 *
 * Конкретные обязанности Ядра ОС (SystemKernel)
 *	Владение аппаратными ресурсами (Hardware Resource Ownership):
 *		Создает и владеет всеми ресурсами (UART, SPI и т.д.) в своем конструкторе.
 *		Гарантирует их корректную инициализацию и освобождение.
 *	Владение задачами (Task Ownership):
 *		Предоставляет API (например, `addTask()`) для регистрации задач в системе.
 *		Хранит и управляет списком всех задач, их состояниями и приоритетами.
 *	Планирование выполнения (Scheduling):
 *		Реализует алгоритм планировщика (в методе `dispatch()`), который постоянно выбирает следующую задачу для выполнения на основе приоритета и состояния (READY, SLEEPING, SUSPENDED).
 *		Обеспечивает квази-параллельное выполнение множества задач.
 *	Управление временем (Time Management):
 *		Предоставляет источник системного времени через системный таймер и счетчик тиков.
 *		Обновляет состояния задач (например, уменьшает счетчики сна) в прерывании таймера (метод `tick()`).
 *		Предоставляет функциям задач API для работы со временем (например, `sleep()`).
 *	Предоставление контролируемого доступа к ресурсам:
 *		Через методы типа `getUART()` ядро предоставляет доступ к ресурсам в рамках модели заимствования (borrowing).
 *		**КРАЙНЕ ВАЖНО:** Эта модель теперь должна быть **безопасной для многозадачной среды**. Это задел на будущее для реализации мьютексов (mutexes) или подобных механизмов, которые будут предотвращать одновременный доступ к ресурсу из разных задач.
 *	Координация конфликтующих ресурсов:
 *		Ядро — единственное место, которое знает обо всех ресурсах и задачах сразу.
 *		Пример: Задача с низким приоритетом заняла ресурс ADC. Задача с высоким приоритетом запрашивает ADC. Ядро может принять решение о приоритетном доступе или организовать очередь.
 *
 * Конкретные обязанности Приложения (Application)
 *   Код приложения (main.cpp) выполняет роль системного интегратора и инициализатора:
 *   Инициализация системы:
 *       Создать экземпляр ядра (SystemKernel).
 *       Вызвать его метод инициализации (`initialize()`).
 *   Декомпозиция логики на задачи:
 *       Главная ответственность — грамотно разбить всю бизнес-логику на отдельные, по возможности независимые, задачи-функции.
 *       Пример: Создать и зарегистрировать: `task_Heartbeat()`, `task_ReadSensor()`, `task_HandleUI()`.
 *   Регистрация задач в ядре:
 *       Передать ядру указатели на функции задач и их приоритеты через API (`addTask()`).
 *   Запуск ядра:
 *       Передать управление бесконечному циклу ядра (`run()`). На этом выполнение кода приложения завершается.
 *
 *   Бизнес-логика внутри задач:
 *       Каждая зарегистрированная функция-задача инкапсулирует свою часть общей логики.
 *       Пример: Задача `task_ReadSensor()`: "Раз в 100 мс прочитать данные с датчика (I2C) -> обработать их -> отправить результат в очередь для других задач".
 *   Кооперативность (Cooperativeness):
 *       Задачи должны быть написаны таким образом, чтобы не блокировать выполнение надолго. Они должны либо быстро завершать свою работу, либо явно отдавать управление планировщику (через `sleep()`)
 *
 *
 * Архитектура ядра
 *
 *		[main.cpp] (Приложение)
 *			|
 *			| Создает, настраивает, запускает
 *			V
 *		[SystemKernel] (Ядро) — Координатор высшего уровня
 *		|           |
 *		|           |
 *		|           | Владеет, управляет жизненным циклом
 *		|           |
 *		V           V
 * [TaskManager]	[ResourceManager]
 * (КТО? КОГДА?)	(ЧЕМ?)
 *		|               |
 *		| Использует    | Предоставляет
 *		V               V
 *	[Task]          [Resource]
 *	(ЧТО?)          (ЧЕМ?)
 *
 *
 *
 *
 *
 *
 *  ВАЖНО: КООПЕРАТИВНАЯ МНОГОЗАДАЧНОСТЬ И "ВЕЖЛИВОСТЬ" ЗАДАЧ
 *
 *  Данная система реализует кооперативную (cooperative) модель многозадачности.
 *  Это означает, что переключение между задачами происходит ТОЛЬКО в тот момент,
 *  когда активная задача ЯВНО и ДОБРОВОЛЬНО отдает управление планировщику.
 *
 *  Ключевые следствия кооперативной модели:
 *
 *  1. ОТСУТСТВИЕ ЖЕСТКИХ ГАРАНТИЙ ВРЕМЕНИ:
 *     - Метод sleep(ms) задает МИНИМАЛЬНОЕ время до следующего пробуждения задачи.
 *     - Реальный интервал между выполнениями задачи = ВремяСна + ВремяВыполненияДругихЗадач.
 *     - Задача гарантированно будет разбужена НЕ РАНЬШЕ чем через указанное время,
 *       но может быть запущена ПОЗЖЕ из-за загрузки системы другими задачами.
 *
 *  2. "ВЕЖЛИВОСТЬ" ЗАДАЧ - ОБЯЗАТЕЛЬНОЕ ТРЕБОВАНИЕ:
 *     - Каждая задача должна либо:
 *         a) Быстро завершать свою работу (занимать минимум процессорного времени)
 *         b) Явно и часто отдавать управление планировщику через sleep() или yield()
 *     - Задача НИКОГДА не должна блокировать выполнение в длительных циклах без
 *       вызова sleep() или других механизмов возврата управления.
 *
 *  3. ОПАСНОСТЬ "ГОЛОДАНИЯ" (STARVATION):
 *     - Если одна задача забудет вызвать sleep() и уйдет в длительный расчет,
 *       ВСЕ остальные задачи системы будут заблокированы до ее завершения.
 *     - Пример НЕВЕЖЛИВОЙ задачи:
 *         void badTask() {
 *             while(1) { Бесконечный цикл без sleep() }
 *         }
 *
 *  4. ПРЕИМУЩЕСТВА КООПЕРАТИВНОЙ МОДЕЛИ:
 *     - Простота реализации и минимальные накладные расходы
 *     - Отсутствие необходимости в синхронизации для разделяемых ресурсов
 *       (поскольку переключение происходит только в известные моменты)
 *     - Детерминированное поведение в пределах одного кванта выполнения
 *
 *  ПРАВИЛА ХОРОШЕГО ТОНА ДЛЯ ЗАДАЧ:
 *
 *  - Делите длинные операции на короткие этапы с промежуточным вызовом sleep(0)
 *  - Для периодических действий используйте sleep() с требуемым интервалом
 *  - Избегайте блокирующих вызовов, которые занимают более 1-2 мс
 *  - Помните: ваша задача - не единственная в системе!
 *
 *  Данная модель идеально подходит для систем с умеренной нагрузкой,
 *  где задачи в основном ожидают внешних событий или работают с периодичностью
 *  в десятки/сотни миллисекунд.
 *
 */
#pragma once

// Проверка поддержки C++11:
#if __cplusplus < 201103L
#error "C++11 support required! Add -std=c++11 to compiler flags"
#endif

// Проверка F_CPU
#ifndef F_CPU
#error "F_CPU must be defined in project settings! Add F_CPU=16000000UL"
#endif

#include <avr/io.h>

// Подключаем только ядро, остальное включается через него
#include "core/SystemKernel.hpp"
#include "drivers/GPIO/GPIO.h"

